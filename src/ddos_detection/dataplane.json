{
    "ingress-path": {
        "name": "Packets feature extractor",
        "code": "/**\n * eBPF C program to be dynamically injected in the kernel.\n * The aim of this program is to extract some info concerning many packets passing through the interface in order to prevent a possible attack.\n * By now the following protocols are checked:\n *  - TCP\n *  - UDP\n *  - ICMP\n *\n * VERSION: 1.0\n */\n\n/*Protocol types according to the standard*/\n#define IPPROTO_TCP 6\n#define IPPROTO_UDP 17\n#define IPPROTO_ICMP 1\n\n#define ECHO_REQUEST 8\n#define ECHO_REPLY  0\n\n/*Own control variables*/\n#define N_SESSION                   1024            // Number of max TCP session tracked\n#define N_PACKET_PER_SESSION        100             // Number of packet from the same TCP session\n#define N_PACKET_TOTAL \\\n    N_SESSION * N_PACKET_PER_SESSION                // Number of max packet captured (Size of PACKET_BUFFER)\n\n/*Session identifier*/\nstruct session_key {\n    __be32 saddr;                                   //IP source address\n    __be32 daddr;                                   //IP dest address\n    __be16 sport;                                   //Source port (if ICMP = 0)\n    __be16 dport;                                   //Dest port (if ICMP = 0)\n    __u8   proto;                                   //Protocol ID\n} __attribute__((packed));\n\n/*Session value*/\nstruct session_value {\n  __be32 server_ip;                                 //The server IP\n  uint64_t n_packets;                               //The number of packet captured so far\n} __attribute__((packed));\n\n/*Features to be exported*/\nstruct features {\n    struct session_key id;                          //Session identifier\n    uint64_t timestamp;                             //Packet timestamp\n    uint16_t ipFlagsFrag;                           //IP flags\n    uint8_t tcpFlags;                               //TCP flags\n    uint16_t tcpWin;                                //TCP window value\n    uint8_t udpSize;                                //UDP payload length\n    uint8_t icmpType;                               //ICMP operation type\n} __attribute__((packed));\n\n/*Ethernet Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/if_ether.h (slightly different)*/\nstruct eth_hdr {\n    __be64 dst: 48;\n    __be64 src: 48;\n    __be16 proto;\n} __attribute__((packed));\n\n/*Ip Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/ip.h */\n/*The \"_\" is useful if mode=XDP_SBK, since already named iphdr*/\nstruct iphdr_ {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n    __u8    ihl:4,\n        version:4;\n#elif defined (__BIG_ENDIAN_BITFIELD)\n    __u8    version:4,\n        ihl:4;\n#else\n#error  \"Please fix <asm/byteorder.h>\"\n#endif\n    __u8 tos;\n    __be16 tot_len;\n    __be16 id;\n    __be16 frag_off;\n    __u8 ttl;\n    __u8 protocol;\n    __sum16 check;\n    __be32 saddr;\n    __be32 daddr;\n    /*The options start here. */\n} __attribute__((packed));\n\n/*TCP Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/tcp.h */\nstruct tcphdr {\n    __be16 source;\n    __be16 dest;\n    __be32 seq;\n    __be32 ack_seq;\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n    __u16   res1:4,\n        doff:4,\n        fin:1,\n        syn:1,\n        rst:1,\n        psh:1,\n        ack:1,\n        urg:1,\n        ece:1,\n        cwr:1;\n#elif defined(__BIG_ENDIAN_BITFIELD)\n    __u16   doff:4,\n        res1:4,\n        cwr:1,\n        ece:1,\n        urg:1,\n        ack:1,\n        psh:1,\n        rst:1,\n        syn:1,\n        fin:1;\n#else\n#error  \"Adjust your <asm/byteorder.h> defines\"\n#endif\n    __be16 window;\n    __sum16 check;\n    __be16 urg_ptr;\n} __attribute__((packed));\n\n/*UDP Header https://github.com/torvalds/linux/blob/master/include/uapi/linux/udp.h */\nstruct udphdr {\n    __be16 source;\n    __be16 dest;\n    __be16 len;\n    __sum16 check;\n} __attribute__((packed));\n\n/*ICMP Header https://github.com/torvalds/linux/blob/master/include/uapi/linux/icmp.h*/\nstruct icmphdr {\n    __u8 type;\n    __u8 code;\n    __sum16 checksum;\n    union {\n        struct {\n            __be16 id;\n            __be16 sequence;\n        } echo;\n        __be32 gateway;\n        struct {\n            __be16 __unused;\n            __be16 mtu;\n        } frag;\n        __u8 reserved[4];\n    } un;\n} __attribute__((packed));\n\n#if POLYCUBE_PROGRAM_TYPE == 0 \nBPF_QUEUESTACK_SHARED(\"queue\",PACKET_BUFFER_DDOS, struct features, N_PACKET_TOTAL, 0);\nBPF_TABLE_SHARED(\"hash\", struct session_key, struct session_value, SESSIONS_TRACKED_DDOS, N_SESSION);\n#else\nBPF_QUEUESTACK(\"extern\", PACKET_BUFFER_DDOS, struct features, N_PACKET_TOTAL, 0);\nBPF_TABLE(\"extern\", struct session_key, struct session_value, SESSIONS_TRACKED_DDOS, N_SESSION);\n#endif\n\n/*Method to return the session identifier, with the lower IP as first member*/\nstatic __always_inline struct session_key get_key(uint32_t ip_a, uint32_t ip_b, uint16_t port_a, uint16_t port_b, uint8_t proto) {\n  if(ip_a < ip_b) {\n    struct session_key ret = {.saddr=ip_a, .daddr=ip_b, .sport=port_a, .dport=port_b, .proto=proto};\n    return ret;\n  } else {\n    struct session_key ret = {.saddr=ip_b, .daddr=ip_a, .sport=port_b, .dport=port_a, .proto=proto};\n    return ret;\n  }\n}\n\n/*Method to determine which member of the communication is the server*/\nstatic __always_inline __be32 heuristic_server(uint32_t src_ip, uint32_t dst_ip, uint16_t src_port, uint16_t dst_port, struct tcphdr *tcp, struct icmphdr *icmp) {\n  /*If Syn, then srcIp is the server*/\n  if(tcp && tcp->syn) {/*If source port < 1024, then srcIp is the server*/\n    return tcp->ack? src_ip : dst_ip;\n  }\n  /*Check if Echo Request/Reply*/\n  if(icmp) {\n    if(icmp->type == ECHO_REQUEST)\n      return dst_ip;\n    if(icmp->type == ECHO_REPLY)\n      return src_ip;\n  }\n  dst_port = bpf_htons(dst_port);\n  /*If destination port < 1024, then dstIp is the server*/\n  if(dst_port < 1024) {\n    return dst_ip;\n  }\n  src_port = bpf_htons(src_port);\n  /*If source port < 1024, then srcIp is the server*/\n  if(src_port < 1024) {\n    return src_ip;\n  }\n  /*Otherwise, the lowest port is the server*/\n  return dst_port <= src_port ? dst_ip : src_ip;\n}\n\n/*Default function called at each packet on interface*/\nstatic __always_inline int handle_rx(struct CTXTYPE *ctx, struct pkt_metadata *md) {\n  void *data = (void *) (long) ctx->data;\n  void *data_end = (void *) (long) ctx->data_end;\n\n  /*Parsing L2*/\n  struct eth_hdr *ethernet = data;\n  if (data + sizeof(*ethernet) > data_end)\n    return RX_OK;\n\n  if (ethernet->proto != bpf_htons(ETH_P_IP))\n    return RX_OK;\n\n  /*Parsing L3*/\n  struct iphdr_ *ip = data + sizeof(struct eth_hdr);\n  if (data + sizeof(struct eth_hdr) + sizeof(*ip) > data_end)\n    return RX_OK;\n  if ((int) ip->version != 4)\n    return RX_OK;\n\n  /*Checking for considered protocols*/\n  if (ip->protocol != IPPROTO_TCP && ip->protocol != IPPROTO_UDP && ip->protocol != IPPROTO_ICMP) {\n    return RX_OK;\n  }\n\n  /*Calculating ip header length\n   * value to multiply by 4 (SHL 2)\n   *e.g. ip->ihl = 5 ; TCP Header starts at = 5 x 4 byte = 20 byte */\n  uint8_t ip_header_len = ip->ihl << 2;\n  \n  /*Checking if packed is already timestamped, otherwise get it from kernel bpf function*/\n  uint64_t curr_time = pcn_get_time_epoch();\n  struct session_value zero = {.n_packets=0, .server_ip=0};\n\n  switch (ip->protocol) {\n    case IPPROTO_TCP: {\n      /*Parsing L4 TCP*/\n      struct tcphdr *tcp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) tcp + sizeof(*tcp) > data_end) {\n        return RX_OK;\n      }\n      /*Check if it is already tracked or try to track it*/\n      struct session_key key = get_key(ip->saddr, ip->daddr, tcp->source, tcp->dest, ip->protocol);\n      struct session_value *value = SESSIONS_TRACKED_DDOS.lookup_or_try_init(&key, &zero);\n      if(!value) {\n        break;\n      }\n\n      /*Check if max packet reached*/\n      if(value->n_packets == N_PACKET_PER_SESSION){\n        break;\n      } else if(value->n_packets == 0){\n        value->server_ip = heuristic_server(ip->saddr, ip->daddr, tcp->source, tcp->dest, tcp, NULL);\n      }\n      value->n_packets +=1;\n\n      /*Now I'm sure to take the packet*/\n      struct features new_features = {.id=key, .timestamp=curr_time, .ipFlagsFrag=bpf_ntohs(ip->frag_off),\n        .tcpWin=bpf_ntohs(tcp->window),\n        .tcpFlags=(tcp->cwr << 7) | (tcp->ece << 6) | (tcp->urg << 5) | (tcp->ack << 4)\n                | (tcp->psh << 3)| (tcp->rst << 2) | (tcp->syn << 1) | tcp->fin};\n      \n      /*Push those features into PACKET_BUFFER*/\n      PACKET_BUFFER_DDOS.push(&new_features, 0);\n      break;\n    }\n    case IPPROTO_ICMP: {\n      /*Parsing L4 ICMP*/\n      struct icmphdr *icmp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) icmp + sizeof(*icmp) > data_end) {\n        return RX_OK;\n      }\n\n      /*Check if it is already tracked or try to track it*/\n      struct session_key key = get_key(ip->saddr, ip->daddr, 0, 0, ip->protocol);\n      struct session_value *value = SESSIONS_TRACKED_DDOS.lookup_or_try_init(&key, &zero);\n      if(!value) {\n        break;\n      }\n\n      /*Check if max packet reached*/\n      if(value->n_packets == N_PACKET_PER_SESSION){\n        break;\n      } else if(value->n_packets == 0){\n        value->server_ip = heuristic_server(ip->saddr, ip->daddr, 0, 0, NULL, icmp);\n      }\n      value->n_packets +=1;\n\n      /*Now I'm sure to take the packet*/\n      struct features new_features = {.id=key, .icmpType=icmp->type, .timestamp=curr_time, .ipFlagsFrag=bpf_ntohs(ip->frag_off)};\n      \n      /*Push those features into PACKET_BUFFER*/\n      PACKET_BUFFER_DDOS.push(&new_features, 0);\n      break;\n    }\n    case IPPROTO_UDP: {\n      /*Parsing L4 UDP*/\n      struct udphdr *udp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) udp + sizeof(*udp) > data_end) {\n        return RX_OK;\n      }\n\n      /*Check if it is already tracked or try to track it*/\n      struct session_key key = get_key(ip->saddr, ip->daddr, udp->source, udp->dest, ip->protocol);\n      struct session_value *value = SESSIONS_TRACKED_DDOS.lookup_or_try_init(&key, &zero);\n      if(!value) {\n        break;\n      }\n\n      /*Check if max packet reached*/\n      if(value->n_packets == N_PACKET_PER_SESSION){\n        break;\n      } else if(value->n_packets == 0){\n        value->server_ip = heuristic_server(ip->saddr, ip->daddr, udp->source, udp->dest, NULL, NULL);\n      }\n      value->n_packets +=1;\n\n      /*Now I'm sure to take the packet*/\n      struct features new_features = {.id=key, .udpSize=bpf_ntohs(udp->len) - sizeof(*udp), .timestamp=curr_time, .ipFlagsFrag=bpf_ntohs(ip->frag_off)};\n      \n      /*Push those features into PACKET_BUFFER*/\n      PACKET_BUFFER_DDOS.push(&new_features, 0);\n      break;\n    }\n    /*Should never reach this code since already checked*/\n    default : {\n      return RX_OK;\n    }\n  }\n\n  return RX_OK;\n}",
        "metric-configs": [
            {
                "name": "PACKET_BUFFER_DDOS",
                "map-name": "PACKET_BUFFER_DDOS",
                "extraction-options": {
                    "swap-on-read": true,
                    "empty-on-read": true
                }
            },
            {
                "name": "SESSIONS_TRACKED_DDOS",
                "map-name": "SESSIONS_TRACKED_DDOS",
                "extraction-options": {
                    "swap-on-read": true,
                    "empty-on-read": true   
                }
            }
        ]
    },
    "egress-path": {
        "name": "Packets feature extractor",
        "code": "/**\n * eBPF C program to be dynamically injected in the kernel.\n * The aim of this program is to extract some info concerning many packets passing through the interface in order to prevent a possible attack.\n * By now the following protocols are checked:\n *  - TCP\n *  - UDP\n *  - ICMP\n *\n * VERSION: 1.0\n */\n\n/*Protocol types according to the standard*/\n#define IPPROTO_TCP 6\n#define IPPROTO_UDP 17\n#define IPPROTO_ICMP 1\n\n#define ECHO_REQUEST 8\n#define ECHO_REPLY  0\n\n/*Own control variables*/\n#define N_SESSION                   1024            // Number of max TCP session tracked\n#define N_PACKET_PER_SESSION        100             // Number of packet from the same TCP session\n#define N_PACKET_TOTAL \\\n    N_SESSION * N_PACKET_PER_SESSION                // Number of max packet captured (Size of PACKET_BUFFER)\n\n/*Session identifier*/\nstruct session_key {\n    __be32 saddr;                                   //IP source address\n    __be32 daddr;                                   //IP dest address\n    __be16 sport;                                   //Source port (if ICMP = 0)\n    __be16 dport;                                   //Dest port (if ICMP = 0)\n    __u8   proto;                                   //Protocol ID\n} __attribute__((packed));\n\n/*Session value*/\nstruct session_value {\n  __be32 server_ip;                                 //The server IP\n  uint64_t n_packets;                               //The number of packet captured so far\n} __attribute__((packed));\n\n/*Features to be exported*/\nstruct features {\n    struct session_key id;                          //Session identifier\n    uint64_t timestamp;                             //Packet timestamp\n    uint16_t ipFlagsFrag;                           //IP flags\n    uint8_t tcpFlags;                               //TCP flags\n    uint16_t tcpWin;                                //TCP window value\n    uint8_t udpSize;                                //UDP payload length\n    uint8_t icmpType;                               //ICMP operation type\n} __attribute__((packed));\n\n/*Ethernet Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/if_ether.h (slightly different)*/\nstruct eth_hdr {\n    __be64 dst: 48;\n    __be64 src: 48;\n    __be16 proto;\n} __attribute__((packed));\n\n/*Ip Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/ip.h */\n/*The \"_\" is useful if mode=XDP_SBK, since already named iphdr*/\nstruct iphdr_ {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n    __u8    ihl:4,\n        version:4;\n#elif defined (__BIG_ENDIAN_BITFIELD)\n    __u8    version:4,\n        ihl:4;\n#else\n#error  \"Please fix <asm/byteorder.h>\"\n#endif\n    __u8 tos;\n    __be16 tot_len;\n    __be16 id;\n    __be16 frag_off;\n    __u8 ttl;\n    __u8 protocol;\n    __sum16 check;\n    __be32 saddr;\n    __be32 daddr;\n    /*The options start here. */\n} __attribute__((packed));\n\n/*TCP Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/tcp.h */\nstruct tcphdr {\n    __be16 source;\n    __be16 dest;\n    __be32 seq;\n    __be32 ack_seq;\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n    __u16   res1:4,\n        doff:4,\n        fin:1,\n        syn:1,\n        rst:1,\n        psh:1,\n        ack:1,\n        urg:1,\n        ece:1,\n        cwr:1;\n#elif defined(__BIG_ENDIAN_BITFIELD)\n    __u16   doff:4,\n        res1:4,\n        cwr:1,\n        ece:1,\n        urg:1,\n        ack:1,\n        psh:1,\n        rst:1,\n        syn:1,\n        fin:1;\n#else\n#error  \"Adjust your <asm/byteorder.h> defines\"\n#endif\n    __be16 window;\n    __sum16 check;\n    __be16 urg_ptr;\n} __attribute__((packed));\n\n/*UDP Header https://github.com/torvalds/linux/blob/master/include/uapi/linux/udp.h */\nstruct udphdr {\n    __be16 source;\n    __be16 dest;\n    __be16 len;\n    __sum16 check;\n} __attribute__((packed));\n\n/*ICMP Header https://github.com/torvalds/linux/blob/master/include/uapi/linux/icmp.h*/\nstruct icmphdr {\n    __u8 type;\n    __u8 code;\n    __sum16 checksum;\n    union {\n        struct {\n            __be16 id;\n            __be16 sequence;\n        } echo;\n        __be32 gateway;\n        struct {\n            __be16 __unused;\n            __be16 mtu;\n        } frag;\n        __u8 reserved[4];\n    } un;\n} __attribute__((packed));\n\n#if POLYCUBE_PROGRAM_TYPE == 0 \nBPF_QUEUESTACK_SHARED(\"queue\",PACKET_BUFFER_DDOS, struct features, N_PACKET_TOTAL, 0);\nBPF_TABLE_SHARED(\"hash\", struct session_key, struct session_value, SESSIONS_TRACKED_DDOS, N_SESSION);\n#else\nBPF_QUEUESTACK(\"extern\", PACKET_BUFFER_DDOS, struct features, N_PACKET_TOTAL, 0);\nBPF_TABLE(\"extern\", struct session_key, struct session_value, SESSIONS_TRACKED_DDOS, N_SESSION);\n#endif\n\n/*Method to return the session identifier, with the lower IP as first member*/\nstatic __always_inline struct session_key get_key(uint32_t ip_a, uint32_t ip_b, uint16_t port_a, uint16_t port_b, uint8_t proto) {\n  if(ip_a < ip_b) {\n    struct session_key ret = {.saddr=ip_a, .daddr=ip_b, .sport=port_a, .dport=port_b, .proto=proto};\n    return ret;\n  } else {\n    struct session_key ret = {.saddr=ip_b, .daddr=ip_a, .sport=port_b, .dport=port_a, .proto=proto};\n    return ret;\n  }\n}\n\n/*Method to determine which member of the communication is the server*/\nstatic __always_inline __be32 heuristic_server(uint32_t src_ip, uint32_t dst_ip, uint16_t src_port, uint16_t dst_port, struct tcphdr *tcp, struct icmphdr *icmp) {\n  /*If Syn, then srcIp is the server*/\n  if(tcp && tcp->syn) {/*If source port < 1024, then srcIp is the server*/\n    return tcp->ack? src_ip : dst_ip;\n  }\n  /*Check if Echo Request/Reply*/\n  if(icmp) {\n    if(icmp->type == ECHO_REQUEST)\n      return dst_ip;\n    if(icmp->type == ECHO_REPLY)\n      return src_ip;\n  }\n  dst_port = bpf_htons(dst_port);\n  /*If destination port < 1024, then dstIp is the server*/\n  if(dst_port < 1024) {\n    return dst_ip;\n  }\n  src_port = bpf_htons(src_port);\n  /*If source port < 1024, then srcIp is the server*/\n  if(src_port < 1024) {\n    return src_ip;\n  }\n  /*Otherwise, the lowest port is the server*/\n  return dst_port <= src_port ? dst_ip : src_ip;\n}\n\n/*Default function called at each packet on interface*/\nstatic __always_inline int handle_rx(struct CTXTYPE *ctx, struct pkt_metadata *md) {\n  void *data = (void *) (long) ctx->data;\n  void *data_end = (void *) (long) ctx->data_end;\n\n  /*Parsing L2*/\n  struct eth_hdr *ethernet = data;\n  if (data + sizeof(*ethernet) > data_end)\n    return RX_OK;\n\n  if (ethernet->proto != bpf_htons(ETH_P_IP))\n    return RX_OK;\n\n  /*Parsing L3*/\n  struct iphdr_ *ip = data + sizeof(struct eth_hdr);\n  if (data + sizeof(struct eth_hdr) + sizeof(*ip) > data_end)\n    return RX_OK;\n  if ((int) ip->version != 4)\n    return RX_OK;\n\n  /*Checking for considered protocols*/\n  if (ip->protocol != IPPROTO_TCP && ip->protocol != IPPROTO_UDP && ip->protocol != IPPROTO_ICMP) {\n    return RX_OK;\n  }\n\n  /*Calculating ip header length\n   * value to multiply by 4 (SHL 2)\n   *e.g. ip->ihl = 5 ; TCP Header starts at = 5 x 4 byte = 20 byte */\n  uint8_t ip_header_len = ip->ihl << 2;\n  \n  /*Checking if packed is already timestamped, otherwise get it from kernel bpf function*/\n  uint64_t curr_time = pcn_get_time_epoch();\n  struct session_value zero = {.n_packets=0, .server_ip=0};\n\n  switch (ip->protocol) {\n    case IPPROTO_TCP: {\n      /*Parsing L4 TCP*/\n      struct tcphdr *tcp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) tcp + sizeof(*tcp) > data_end) {\n        return RX_OK;\n      }\n      /*Check if it is already tracked or try to track it*/\n      struct session_key key = get_key(ip->saddr, ip->daddr, tcp->source, tcp->dest, ip->protocol);\n      struct session_value *value = SESSIONS_TRACKED_DDOS.lookup_or_try_init(&key, &zero);\n      if(!value) {\n        break;\n      }\n\n      /*Check if max packet reached*/\n      if(value->n_packets == N_PACKET_PER_SESSION){\n        break;\n      } else if(value->n_packets == 0){\n        value->server_ip = heuristic_server(ip->saddr, ip->daddr, tcp->source, tcp->dest, tcp, NULL);\n      }\n      value->n_packets +=1;\n\n      /*Now I'm sure to take the packet*/\n      struct features new_features = {.id=key, .timestamp=curr_time, .ipFlagsFrag=bpf_ntohs(ip->frag_off),\n        .tcpWin=bpf_ntohs(tcp->window),\n        .tcpFlags=(tcp->cwr << 7) | (tcp->ece << 6) | (tcp->urg << 5) | (tcp->ack << 4)\n                | (tcp->psh << 3)| (tcp->rst << 2) | (tcp->syn << 1) | tcp->fin};\n      \n      /*Push those features into PACKET_BUFFER*/\n      PACKET_BUFFER_DDOS.push(&new_features, 0);\n      break;\n    }\n    case IPPROTO_ICMP: {\n      /*Parsing L4 ICMP*/\n      struct icmphdr *icmp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) icmp + sizeof(*icmp) > data_end) {\n        return RX_OK;\n      }\n\n      /*Check if it is already tracked or try to track it*/\n      struct session_key key = get_key(ip->saddr, ip->daddr, 0, 0, ip->protocol);\n      struct session_value *value = SESSIONS_TRACKED_DDOS.lookup_or_try_init(&key, &zero);\n      if(!value) {\n        break;\n      }\n\n      /*Check if max packet reached*/\n      if(value->n_packets == N_PACKET_PER_SESSION){\n        break;\n      } else if(value->n_packets == 0){\n        value->server_ip = heuristic_server(ip->saddr, ip->daddr, 0, 0, NULL, icmp);\n      }\n      value->n_packets +=1;\n\n      /*Now I'm sure to take the packet*/\n      struct features new_features = {.id=key, .icmpType=icmp->type, .timestamp=curr_time, .ipFlagsFrag=bpf_ntohs(ip->frag_off)};\n      \n      /*Push those features into PACKET_BUFFER*/\n      PACKET_BUFFER_DDOS.push(&new_features, 0);\n      break;\n    }\n    case IPPROTO_UDP: {\n      /*Parsing L4 UDP*/\n      struct udphdr *udp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) udp + sizeof(*udp) > data_end) {\n        return RX_OK;\n      }\n\n      /*Check if it is already tracked or try to track it*/\n      struct session_key key = get_key(ip->saddr, ip->daddr, udp->source, udp->dest, ip->protocol);\n      struct session_value *value = SESSIONS_TRACKED_DDOS.lookup_or_try_init(&key, &zero);\n      if(!value) {\n        break;\n      }\n\n      /*Check if max packet reached*/\n      if(value->n_packets == N_PACKET_PER_SESSION){\n        break;\n      } else if(value->n_packets == 0){\n        value->server_ip = heuristic_server(ip->saddr, ip->daddr, udp->source, udp->dest, NULL, NULL);\n      }\n      value->n_packets +=1;\n\n      /*Now I'm sure to take the packet*/\n      struct features new_features = {.id=key, .udpSize=bpf_ntohs(udp->len) - sizeof(*udp), .timestamp=curr_time, .ipFlagsFrag=bpf_ntohs(ip->frag_off)};\n      \n      /*Push those features into PACKET_BUFFER*/\n      PACKET_BUFFER_DDOS.push(&new_features, 0);\n      break;\n    }\n    /*Should never reach this code since already checked*/\n    default : {\n      return RX_OK;\n    }\n  }\n\n  return RX_OK;\n}",
        "metric-configs": [
            {
                "name": "PACKET_BUFFER_DDOS",
                "map-name": "PACKET_BUFFER_DDOS",
                "extraction-options": {
                    "swap-on-read": true,
                    "empty-on-read": true
                }
            },
            {
                "name": "SESSIONS_TRACKED_DDOS",
                "map-name": "SESSIONS_TRACKED_DDOS",
                "extraction-options": {
                    "swap-on-read": true,
                    "empty-on-read": true   
                }
            }
        ]
    }
}