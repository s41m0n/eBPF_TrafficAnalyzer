{
    "ingress-path": {
        "name": "Packets feature extractor",
        "code": "/**\n * eBPF C program to be dynamically injected in the kernel.\n * The aim of this program is to extract some info concerning many packets passing through the interface in order to prevent a possible attack.\n * By now the following protocols are checked:\n *  - TCP\n *  - UDP\n */\n\n/*Protocol types according to the standard*/\n#define IPPROTO_TCP 6\n#define IPPROTO_UDP 17\n\n/* Number of max TCP session tracked */\n#define N_SESSION 10000\n#define SESSION_DROP_AFTER_TIME 30000000000\n\n/*Features to be exported*/\nstruct features {\n    //Real features\n    uint64_t n_packets_server;                      // Number of packets from server\n    uint64_t n_packets_client;                      // Number of packets from client\n    uint64_t n_bits_server;                         // Total bits from server\n    uint64_t n_bits_client;                         // Total bits from client\n    uint64_t start_timestamp;                       // Connection begin timestamp\n    uint64_t alive_timestamp;                       // Last message received timestamp\n    uint8_t  method;                                // The method used to determine the server\n    __be32 server_ip;                               // The server address\n} __attribute__((packed));\n\n/*Session identifier*/\nstruct session_key {\n    __be32 saddr;                                   //IP source address\n    __be32 daddr;                                   //IP dest address\n    __be16 sport;                                   //Source port\n    __be16 dport;                                   //Dest port\n    __u8   proto;                                   //Protocol ID\n} __attribute__((packed));\n\n/*Ethernet Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/if_ether.h (slightly different)*/\nstruct eth_hdr {\n    __be64 dst: 48;\n    __be64 src: 48;\n    __be16 proto;\n} __attribute__((packed));\n\n/*Ip Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/ip.h */\nstruct iphdr {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n    __u8    ihl:4,\n        version:4;\n#elif defined (__BIG_ENDIAN_BITFIELD)\n    __u8    version:4,\n        ihl:4;\n#else\n#error  \"Please fix <asm/byteorder.h>\"\n#endif\n    __u8 tos;\n    __be16 tot_len;\n    __be16 id;\n    __be16 frag_off;\n    __u8 ttl;\n    __u8 protocol;\n    __sum16 check;\n    __be32 saddr;\n    __be32 daddr;\n    /*The options start here. */\n} __attribute__((packed));\n\n/*TCP Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/tcp.h */\nstruct tcphdr {\n    __be16 source;\n    __be16 dest;\n    __be32 seq;\n    __be32 ack_seq;\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n    __u16   res1:4,\n        doff:4,\n        fin:1,\n        syn:1,\n        rst:1,\n        psh:1,\n        ack:1,\n        urg:1,\n        ece:1,\n        cwr:1;\n#elif defined(__BIG_ENDIAN_BITFIELD)\n    __u16   doff:4,\n        res1:4,\n        cwr:1,\n        ece:1,\n        urg:1,\n        ack:1,\n        psh:1,\n        rst:1,\n        syn:1,\n        fin:1;\n#else\n#error  \"Adjust your <asm/byteorder.h> defines\"\n#endif\n    __be16 window;\n    __sum16 check;\n    __be16 urg_ptr;\n} __attribute__((packed));\n\n/*UDP Header https://github.com/torvalds/linux/blob/master/include/uapi/linux/udp.h */\nstruct udphdr {\n    __be16 source;\n    __be16 dest;\n    __be16 len;\n    __sum16 check;\n} __attribute__((packed));\n\n/*Tracked session LRU map*/\nBPF_TABLE_SHARED(\"lru_hash\", struct session_key, struct features, SESSIONS_TRACKED_CRYPTO, N_SESSION);\n\n/*Method to determine which member of the communication is the server*/\nstatic __always_inline __be32 heuristic_server_tcp(struct iphdr *ip, struct tcphdr *tcp, uint8_t *method) {\n  /*If Syn, then srcIp is the server*/\n  if(tcp->syn) {/*If source port < 1024, then srcIp is the server*/\n    *method = 1;\n    return tcp->ack? ip->saddr : ip->daddr;\n  }\n\n  uint16_t dst_port = bpf_htons(tcp->dest);\n  /*If destination port < 1024, then dstIp is the server*/\n  if(dst_port < 1024) {\n    *method = 2;\n    return ip->daddr;\n  }\n\n  uint16_t src_port = bpf_htons(tcp->source);\n  /*If source port < 1024, then srcIp is the server*/\n  if(src_port < 1024) {\n    *method = 2;\n    return ip->saddr;\n  }\n\n  *method = 3;\n  /*Otherwise, the lowest port is the server*/\n  return dst_port < src_port ? ip->daddr : ip->saddr;\n}\n\nstatic __always_inline __be32 heuristic_server_udp(struct iphdr *ip, struct udphdr *udp, uint8_t *method) {\n  /*If destination port < 1024, then dstIp is the server*/\n  uint16_t dst_port = bpf_htons(udp->dest);\n  if(dst_port < 1024) {\n    *method = 2;\n    return ip->daddr;\n  }\n\n  uint16_t src_port = bpf_htons(udp->source);\n  /*If source port < 1024, then srcIp is the server*/\n  if(src_port < 1024) {\n    *method = 2;\n    return ip->saddr;\n  }\n\n  *method = 3;\n  /*Otherwise, the lowest port is the server*/\n  return dst_port < src_port ? ip->daddr : ip->saddr;\n}\n\n/*Method to add a new session in the map*/\nstatic __always_inline void insert_new_session(__be32 server, uint64_t curr_time, uint16_t pkt_len, bool is_server, struct session_key *key, uint8_t method) {\n  if(is_server) {\n    struct features new_val = {.n_packets_server=1, .n_bits_server=pkt_len, .start_timestamp=curr_time, .alive_timestamp=curr_time, .server_ip=server, .method=method};  \n    SESSIONS_TRACKED_CRYPTO.insert(key, &new_val);\n  } else {\n    struct features new_val = {.n_packets_client=1, .n_bits_client=pkt_len, .start_timestamp=curr_time, .alive_timestamp=curr_time, .server_ip=server, .method=method};\n    SESSIONS_TRACKED_CRYPTO.insert(key, &new_val);\n  }\n}\n\nstatic __always_inline void update_expired_session(__be32 server, uint64_t curr_time, uint16_t pkt_len, bool is_server, struct session_key *key, uint8_t method) {\n  if(is_server) {\n    struct features new_val = {.n_packets_server=1, .n_bits_server=pkt_len, .start_timestamp=curr_time, .alive_timestamp=curr_time, .server_ip=server, .method=method};  \n    SESSIONS_TRACKED_CRYPTO.update(key, &new_val);\n  } else {\n    struct features new_val = {.n_packets_client=1, .n_bits_client=pkt_len, .start_timestamp=curr_time, .alive_timestamp=curr_time, .server_ip=server, .method=method};\n    SESSIONS_TRACKED_CRYPTO.update(key, &new_val);\n  }\n}\n\nstatic __always_inline void update_session(struct features *value, uint16_t pkt_len, uint64_t curr_time, bool is_server) {\n  if(is_server) {\n    value->n_packets_server += 1;\n    value->n_bits_server += pkt_len;\n  } else {\n    value->n_packets_client += 1;\n    value->n_bits_client += pkt_len;\n  }\n  value->alive_timestamp = curr_time;\n}\n\nstatic __always_inline int handle_rx(struct CTXTYPE *ctx, struct pkt_metadata *md) {\n  void *data = (void *) (long) ctx->data;\n  void *data_end = (void *) (long) ctx->data_end;\n\n  /*Parsing L2*/\n  struct eth_hdr *ethernet = data;\n  if (data + sizeof(*ethernet) > data_end)\n    return RX_OK;\n\n  if (ethernet->proto != bpf_htons(ETH_P_IP))\n    return RX_OK;\n\n  /*Parsing L3*/\n  struct iphdr *ip = data + sizeof(struct eth_hdr);\n  if (data + sizeof(struct eth_hdr) + sizeof(*ip) > data_end)\n    return RX_OK;\n  if ((int) ip->version != 4)\n    return RX_OK;\n\n  /*Calculating ip header length\n   * value to multiply by 4 (SHL 2)\n   *e.g. ip->ihl = 5 ; TCP Header starts at = 5 x 4 byte = 20 byte */\n  uint8_t ip_header_len = ip->ihl << 2;\n\n  switch (ip->protocol) {\n    case IPPROTO_TCP: {\n      /*Parsing L4 TCP*/\n      struct tcphdr *tcp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) tcp + sizeof(*tcp) > data_end)\n        return RX_OK;\n\n      struct session_key key = {.saddr=ip->saddr, .daddr= ip->daddr, .sport=tcp->source, .dport=tcp->dest, .proto=ip->protocol};\n      /*Checking if packed is already timestamped, otherwise get it from kernel bpf function*/\n      uint64_t curr_time = pcn_get_time_epoch();\n      uint16_t pkt_len = bpf_ntohs(ip->tot_len);\n\n      /*Check if new session*/\n      struct features *value = SESSIONS_TRACKED_CRYPTO.lookup(&key);\n      if (!value) {\n        pcn_log(ctx, LOG_DEBUG, \"INGRESS - TCP New session\");\n        uint8_t method;\n        __be32 server = heuristic_server_tcp(ip, tcp, &method);\n        insert_new_session(server, curr_time, pkt_len, server==ip->saddr, &key, method);\n        break;\n      }\n\n      /*Check if the entry was too old => overwrite it*/\n      if(curr_time - value->alive_timestamp > SESSION_DROP_AFTER_TIME) {\n        pcn_log(ctx, LOG_DEBUG, \"INGRESS - TCP Session overwritten\");\n        uint8_t method;\n        __be32 server = heuristic_server_tcp(ip, tcp, &method);\n        update_expired_session(server, curr_time, pkt_len, server==ip->saddr, &key, method);\n        break;\n      } \n\n      /*Update current session*/\n      update_session(value, pkt_len, curr_time, value->server_ip==ip->saddr);\n      pcn_log(ctx, LOG_DEBUG, \"INGRESS - TCP Session updated\");\n      break;\n    }\n    case IPPROTO_UDP: {\n      /*Parsing L4 UDP*/\n      struct udphdr *udp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) udp + sizeof(*udp) > data_end) {\n        return RX_OK;\n      }\n\n      struct session_key key = {.saddr=ip->saddr, .daddr= ip->daddr, .sport=udp->source, .dport=udp->dest, .proto=ip->protocol};\n      /*Checking if packed is already timestamped, otherwise get it from kernel bpf function*/\n      uint64_t curr_time = pcn_get_time_epoch();\n      uint16_t pkt_len = bpf_ntohs(ip->tot_len);\n\n      /*Check if new session*/\n      struct features *value = SESSIONS_TRACKED_CRYPTO.lookup(&key);\n      if (!value) {\n        pcn_log(ctx, LOG_DEBUG, \"INGRESS - UDP New session\");\n        uint8_t method;\n        __be32 server = heuristic_server_udp(ip, udp, &method);\n        insert_new_session(server, curr_time, pkt_len, server==ip->saddr, &key, method);\n        break;\n      }\n\n      /*Check if the entry was too old => overwrite it*/\n      if(curr_time - value->alive_timestamp > SESSION_DROP_AFTER_TIME) {\n        pcn_log(ctx, LOG_DEBUG, \"INGRESS - UDP Session overwritten\");\n        uint8_t method;\n        __be32 server = heuristic_server_udp(ip, udp, &method);\n        update_expired_session(server, curr_time, pkt_len, server==ip->saddr, &key, method);\n        break;\n      } \n\n      /*Update current session*/\n      update_session(value, pkt_len, curr_time, value->server_ip==ip->saddr);\n      pcn_log(ctx, LOG_DEBUG, \"INGRESS - UDP Session updated\");\n      break;\n    }\n    /*Ignored protocol*/\n    default : {\n      return RX_OK;\n    }\n  }\n\n  /* Here operations after the capture */\n  return RX_OK;\n}",
        "metric-configs": [
            {
                "name": "SESSIONS_TRACKED_CRYPTO",
                "map-name": "SESSIONS_TRACKED_CRYPTO"
            }
        ]
    },
    "egress-path": {
        "name": "Packets feature extractor",
        "code": "/**\n * eBPF C program to be dynamically injected in the kernel.\n * The aim of this program is to extract some info concerning many packets passing through the interface in order to prevent a possible attack.\n * By now the following protocols are checked:\n *  - TCP\n *  - UDP\n */\n\n/*Protocol types according to the standard*/\n#define IPPROTO_TCP 6\n#define IPPROTO_UDP 17\n\n/* Number of max TCP session tracked */\n#define N_SESSION 10000\n#define SESSION_DROP_AFTER_TIME 30000000000\n\n/*Features to be exported*/\nstruct features {\n    //Real features\n    uint64_t n_packets_server;                      // Number of packets from server\n    uint64_t n_packets_client;                      // Number of packets from client\n    uint64_t n_bits_server;                         // Total bits from server\n    uint64_t n_bits_client;                         // Total bits from client\n    uint64_t start_timestamp;                       // Connection begin timestamp\n    uint64_t alive_timestamp;                       // Last message received timestamp\n    uint8_t  method;                                // The method used to determine the server\n    __be32 server_ip;                               // The server address\n} __attribute__((packed));\n\n/*Session identifier*/\nstruct session_key {\n    __be32 saddr;                                   //IP source address\n    __be32 daddr;                                   //IP dest address\n    __be16 sport;                                   //Source port\n    __be16 dport;                                   //Dest port\n    __u8   proto;                                   //Protocol ID\n} __attribute__((packed));\n\n/*Ethernet Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/if_ether.h (slightly different)*/\nstruct eth_hdr {\n    __be64 dst: 48;\n    __be64 src: 48;\n    __be16 proto;\n} __attribute__((packed));\n\n/*Ip Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/ip.h */\nstruct iphdr {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n    __u8    ihl:4,\n        version:4;\n#elif defined (__BIG_ENDIAN_BITFIELD)\n    __u8    version:4,\n        ihl:4;\n#else\n#error  \"Please fix <asm/byteorder.h>\"\n#endif\n    __u8 tos;\n    __be16 tot_len;\n    __be16 id;\n    __be16 frag_off;\n    __u8 ttl;\n    __u8 protocol;\n    __sum16 check;\n    __be32 saddr;\n    __be32 daddr;\n    /*The options start here. */\n} __attribute__((packed));\n\n/*TCP Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/tcp.h */\nstruct tcphdr {\n    __be16 source;\n    __be16 dest;\n    __be32 seq;\n    __be32 ack_seq;\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n    __u16   res1:4,\n        doff:4,\n        fin:1,\n        syn:1,\n        rst:1,\n        psh:1,\n        ack:1,\n        urg:1,\n        ece:1,\n        cwr:1;\n#elif defined(__BIG_ENDIAN_BITFIELD)\n    __u16   doff:4,\n        res1:4,\n        cwr:1,\n        ece:1,\n        urg:1,\n        ack:1,\n        psh:1,\n        rst:1,\n        syn:1,\n        fin:1;\n#else\n#error  \"Adjust your <asm/byteorder.h> defines\"\n#endif\n    __be16 window;\n    __sum16 check;\n    __be16 urg_ptr;\n} __attribute__((packed));\n\n/*UDP Header https://github.com/torvalds/linux/blob/master/include/uapi/linux/udp.h */\nstruct udphdr {\n    __be16 source;\n    __be16 dest;\n    __be16 len;\n    __sum16 check;\n} __attribute__((packed));\n\n/*Tracked session LRU map*/\nBPF_TABLE(\"extern\", struct session_key, struct features, SESSIONS_TRACKED_CRYPTO, N_SESSION);\n\n/*Method to determine which member of the communication is the server*/\nstatic __always_inline __be32 heuristic_server_tcp(struct iphdr *ip, struct tcphdr *tcp, uint8_t *method) {\n  /*If Syn, then srcIp is the server*/\n  if(tcp->syn) {/*If source port < 1024, then srcIp is the server*/\n    *method = 1;\n    return tcp->ack? ip->saddr : ip->daddr;\n  }\n\n  uint16_t dst_port = bpf_htons(tcp->dest);\n  /*If destination port < 1024, then dstIp is the server*/\n  if(dst_port < 1024) {\n    *method = 2;\n    return ip->daddr;\n  }\n\n  uint16_t src_port = bpf_htons(tcp->source);\n  /*If source port < 1024, then srcIp is the server*/\n  if(src_port < 1024) {\n    *method = 2;\n    return ip->saddr;\n  }\n\n  *method = 3;\n  /*Otherwise, the lowest port is the server*/\n  return dst_port < src_port ? ip->daddr : ip->saddr;\n}\n\nstatic __always_inline __be32 heuristic_server_udp(struct iphdr *ip, struct udphdr *udp, uint8_t *method) {\n  /*If destination port < 1024, then dstIp is the server*/\n  uint16_t dst_port = bpf_htons(udp->dest);\n  if(dst_port < 1024) {\n    *method = 2;\n    return ip->daddr;\n  }\n\n  uint16_t src_port = bpf_htons(udp->source);\n  /*If source port < 1024, then srcIp is the server*/\n  if(src_port < 1024) {\n    *method = 2;\n    return ip->saddr;\n  }\n\n  *method = 3;\n  /*Otherwise, the lowest port is the server*/\n  return dst_port < src_port ? ip->daddr : ip->saddr;\n}\n\n/*Method to add a new session in the map*/\nstatic __always_inline void insert_new_session(__be32 server, uint64_t curr_time, uint16_t pkt_len, bool is_server, struct session_key *key, uint8_t method) {\n  if(is_server) {\n    struct features new_val = {.n_packets_server=1, .n_bits_server=pkt_len, .start_timestamp=curr_time, .alive_timestamp=curr_time, .server_ip=server, .method=method};  \n    SESSIONS_TRACKED_CRYPTO.insert(key, &new_val);\n  } else {\n    struct features new_val = {.n_packets_client=1, .n_bits_client=pkt_len, .start_timestamp=curr_time, .alive_timestamp=curr_time, .server_ip=server, .method=method};\n    SESSIONS_TRACKED_CRYPTO.insert(key, &new_val);\n  }\n}\n\nstatic __always_inline void update_expired_session(__be32 server, uint64_t curr_time, uint16_t pkt_len, bool is_server, struct session_key *key, uint8_t method) {\n  if(is_server) {\n    struct features new_val = {.n_packets_server=1, .n_bits_server=pkt_len, .start_timestamp=curr_time, .alive_timestamp=curr_time, .server_ip=server, .method=method};  \n    SESSIONS_TRACKED_CRYPTO.update(key, &new_val);\n  } else {\n    struct features new_val = {.n_packets_client=1, .n_bits_client=pkt_len, .start_timestamp=curr_time, .alive_timestamp=curr_time, .server_ip=server, .method=method};\n    SESSIONS_TRACKED_CRYPTO.update(key, &new_val);\n  }\n}\n\nstatic __always_inline void update_session(struct features *value, uint16_t pkt_len, uint64_t curr_time, bool is_server) {\n  if(is_server) {\n    value->n_packets_server += 1;\n    value->n_bits_server += pkt_len;\n  } else {\n    value->n_packets_client += 1;\n    value->n_bits_client += pkt_len;\n  }\n  value->alive_timestamp = curr_time;\n}\n\nstatic __always_inline int handle_rx(struct CTXTYPE *ctx, struct pkt_metadata *md) {\n  void *data = (void *) (long) ctx->data;\n  void *data_end = (void *) (long) ctx->data_end;\n\n  /*Parsing L2*/\n  struct eth_hdr *ethernet = data;\n  if (data + sizeof(*ethernet) > data_end)\n    return RX_OK;\n\n  if (ethernet->proto != bpf_htons(ETH_P_IP))\n    return RX_OK;\n\n  /*Parsing L3*/\n  struct iphdr *ip = data + sizeof(struct eth_hdr);\n  if (data + sizeof(struct eth_hdr) + sizeof(*ip) > data_end)\n    return RX_OK;\n  if ((int) ip->version != 4)\n    return RX_OK;\n\n  /*Calculating ip header length\n   * value to multiply by 4 (SHL 2)\n   *e.g. ip->ihl = 5 ; TCP Header starts at = 5 x 4 byte = 20 byte */\n  uint8_t ip_header_len = ip->ihl << 2;\n\n  switch (ip->protocol) {\n    case IPPROTO_TCP: {\n      /*Parsing L4 TCP*/\n      struct tcphdr *tcp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) tcp + sizeof(*tcp) > data_end)\n        return RX_OK;\n\n      struct session_key key = {.saddr=ip->daddr, .daddr= ip->saddr, .sport=tcp->dest, .dport=tcp->source, .proto=ip->protocol};\n      /*Checking if packed is already timestamped, otherwise get it from kernel bpf function*/\n      uint64_t curr_time = pcn_get_time_epoch();\n      uint16_t pkt_len = bpf_ntohs(ip->tot_len);\n\n      /*Check if new session*/\n      struct features *value = SESSIONS_TRACKED_CRYPTO.lookup(&key);\n      if (!value) {\n        pcn_log(ctx, LOG_DEBUG, \"EGRESS - TCP New session\");\n        uint8_t method;\n        __be32 server = heuristic_server_tcp(ip, tcp, &method);\n        insert_new_session(server, curr_time, pkt_len, server==ip->saddr, &key, method);\n        break;\n      }\n\n      /*Check if the entry was too old => overwrite it*/\n      if(curr_time - value->alive_timestamp > SESSION_DROP_AFTER_TIME) {\n        pcn_log(ctx, LOG_DEBUG, \"EGRESS - TCP Session overwritten\");\n        uint8_t method;\n        __be32 server = heuristic_server_tcp(ip, tcp, &method);\n        update_expired_session(server, curr_time, pkt_len, server==ip->saddr, &key, method);\n        break;\n      } \n\n      /*Update current session*/\n      update_session(value, pkt_len, curr_time, value->server_ip==ip->saddr);\n      pcn_log(ctx, LOG_DEBUG, \"EGRESS - TCP Session updated\");\n      break;\n    }\n    case IPPROTO_UDP: {\n      /*Parsing L4 UDP*/\n      struct udphdr *udp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) udp + sizeof(*udp) > data_end) {\n        return RX_OK;\n      }\n\n      struct session_key key = {.saddr=ip->daddr, .daddr= ip->saddr, .sport=udp->dest, .dport=udp->source, .proto=ip->protocol};\n      /*Checking if packed is already timestamped, otherwise get it from kernel bpf function*/\n      uint64_t curr_time = pcn_get_time_epoch();\n      uint16_t pkt_len = bpf_ntohs(ip->tot_len);\n\n      /*Check if new session*/\n      struct features *value = SESSIONS_TRACKED_CRYPTO.lookup(&key);\n      if (!value) {\n        pcn_log(ctx, LOG_DEBUG, \"EGRESS - UDP New session\");\n        uint8_t method;\n        __be32 server = heuristic_server_udp(ip, udp, &method);\n        insert_new_session(server, curr_time, pkt_len, server==ip->saddr, &key, method);\n        break;\n      }\n\n      /*Check if the entry was too old => overwrite it*/\n      if(curr_time - value->alive_timestamp > SESSION_DROP_AFTER_TIME) {\n        pcn_log(ctx, LOG_DEBUG, \"EGRESS - UDP Session overwritten\");\n        uint8_t method;\n        __be32 server = heuristic_server_udp(ip, udp, &method);\n        update_expired_session(server, curr_time, pkt_len, server==ip->saddr, &key, method);\n        break;\n      } \n\n      /*Update current session*/\n      update_session(value, pkt_len, curr_time, value->server_ip==ip->saddr);\n      pcn_log(ctx, LOG_DEBUG, \"EGRESS - UDP Session updated\");\n      break;\n    }\n    /*Ignored protocol*/\n    default : {\n      return RX_OK;\n    }\n  }\n\n  /* Here operations after the capture */\n  return RX_OK;\n}",
        "metric-configs": [
            {
                "name": "SESSIONS_TRACKED_CRYPTO",
                "map-name": "SESSIONS_TRACKED_CRYPTO"
            }
        ]
    }
}